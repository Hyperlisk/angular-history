{"name":"angular-history","tagline":"A history service for AngularJS.  Undo/redo, that sort of thing.  Has nothing to do with the \"back\" button, unless you want it to.","body":"angular-history [![Build Status](https://travis-ci.org/decipherinc/angular-history.png?branch=master)](https://travis-ci.org/decipherinc/angular-history)\r\n===============\r\n\r\nA history service for AngularJS.  Undo/redo, that sort of thing.  Has nothing to\r\ndo with the \"back\" button, unless you want it to.\r\n\r\nCurrent Version\r\n===============\r\n```\r\n0.5.0\r\n```\r\n\r\n*Fair warning:* Until this project is at `1.0.0` the API is subject to change\r\nand will likely break.\r\n\r\nInstallation\r\n============\r\n\r\n```\r\nbower install angular-history\r\n```\r\n\r\nRequirements\r\n============\r\n\r\n- AngularJS 1.0.8+\r\n- [ngLazyBind](https://github.com/Ticore/ngLazyBind) (optional)\r\n\r\nRunning Tests\r\n-------------\r\n\r\nClone this repo and execute:\r\n\r\n```\r\nnpm install\r\n```\r\n\r\nto grab the dependencies.  Then execute:\r\n \r\n```\r\ngrunt test\r\n```\r\n\r\nto run the tests.  This will grab the test deps from [bower](http://bower.io),\r\nand run them against [QUnit](http://qunitjs.com) in a local server on port 8000.\r\n\r\nAPI Documentation\r\n=================\r\n\r\n[API Documentation](http://decipherinc.github.io/angular-history/docs)\r\n\r\nDemo\r\n====\r\n\r\nFor now, some in the [API documentation](http://decipherinc.github.io/angular-history/docs).\r\n\r\nUsage\r\n=====\r\n\r\nFirst, include the `decipher.history` module in your application:\r\n\r\n```javascript\r\nangular.module('myApp', ['decipher.history']);\r\n```\r\n\r\nNext, you will want to inject the `History` service into your component:\r\n\r\n```javascript\r\nangular.module('myApp').controller('MyCtrl', function($scope, History) {\r\n    // ...\r\n});\r\n```\r\n\r\nOptionally, you can grab the [ngLazyBind](https://github.com/Ticore/ngLazyBind)\r\nmodule if you want to support lazy binding.  This becomes useful if you have\r\nsay, an `<input type=\"text\">` field, and you don't want every keystroke recorded\r\nin the history.  If this module is present, the `History` service will provide\r\nextra options.\r\n\r\nWatching an Expression\r\n----------------------\r\n\r\nYou will want to give the `History` service an expression to watch:\r\n\r\n```javascript\r\nangular.module('myApp').controller('MyCtrl', function($scope, History) {\r\n    $scope.foo = 'bar';\r\n    History.watch('foo', $scope);\r\n});\r\n```\r\n\r\nAn optional third parameter is the `description`, which will be emitted when an\r\nitem is archived, undone, redone, or reverted, via a `$broadcast()`.   This\r\nallows you to attach to the event and do something with the info, such as pop up\r\n an alert with an \"undo\" button in it.  This value is interpolated against the\r\n passed `$scope` object.\r\n\r\nIf you have the `ngLazyBind` module, you may provide a fourth parameter to\r\n`History.watch()`:\r\n\r\n```javascript\r\nHistory.watch('foo', $scope, 'Foo changed to {{foo}}', {timeout: 500});\r\n```\r\n\r\nThis tells the history stack to update no more often than every 500ms. This\r\nvalue defaults to 1s.  If you wish to use lazy binding with the default, then\r\nsimply pass an empty object `{}` as the fourth parameter.  If you do not have\r\nthe `ngLazyBind` module installed, this object will simply be ignored.\r\n\r\nThe `Watch` Object\r\n------------------\r\n\r\nWhenever you issue one of the following commands, you will receive a `Watch`\r\nobject:\r\n\r\n- `History.watch()`\r\n- `History.deepWatch()`\r\n- `History.batch()`\r\n\r\nThis provides another layer of functionality on top of the events that the\r\n`History` service will broadcast.  You can use these *chainable* objects to run\r\ncallbacks depending on the type of action that was taken:\r\n\r\n```javascript\r\nvar w = History.watch('foo')\r\n  .addChangeHandler('myChangeHandler', function() {\r\n    console.log('foo got changed');\r\n  })\r\n  .addUndoHandler('myUndoHandler', function() {\r\n    console.log('undid foo.  this message will self-destruct');\r\n    w.removeUndoHandler('myUndoHandler');\r\n  });\r\n```\r\n\r\nThe general recommendation is to listen for the global events if you want\r\ngeneral functionality, and to use these `Watch` object callbacks for specific\r\nfunctionality.\r\n\r\nUndoing/Redoing\r\n---------------\r\n\r\nOnce something is `watch()`ed, you can undo or redo changes to it, *if that\r\nexpression is assignable*.  If you pass a function as the expression, you may\r\n*not* undo/redo, but you will still have access to the history stack.\r\n\r\nAnyway, to undo, execute:\r\n\r\n```javascript\r\nHistory.undo('foo', $scope);\r\n```\r\n\r\nThe `$scope` will be updated with the most recent version of the object.  You\r\ncan `undo()` as many times as there are changes in the expression's value since\r\nyou `watch()`ed it--this is an entire history stack.\r\n\r\nFurthermore, an event will be emitted.  The `$rootScope` will `$broadcast()` a\r\n`History.undone` event with the following information:\r\n\r\n- `expression`: The expression that was undone\r\n- `oldValue`: The value the expression was changed from.  This is a copy!\r\n- `newValue`: The value the expression was changed to\r\n- `description`: The optional `description` you may have passed\r\n- `scope`: The scope passed to `undo()`\r\n\r\nRedoing is pretty much as you would expect:\r\n\r\n```javascript\r\nHistory.redo('foo', $scope);\r\n```\r\n\r\nThis only works if you have previously undone something, of course.  You can\r\nundo multiple times, then redo multiple times.  The event emitted after redo is\r\n`History.redone` and the information is the same.\r\n\r\nUse `History.canUndo(exp, scope)` and `History.canRedo(exp, scope)` if you need\r\nto know those things.\r\n\r\nRevert\r\n------\r\n\r\nYou can revert to the original value at the time of the `watch()` instruction by\r\nissuing:\r\n\r\n```javascript\r\nHistory.revert('foo', $scope);\r\n```\r\n\r\nIf you are looking at `History.history` and know where in the stack you want to\r\ngo, pass a third parameter and you will revert to a specific revision in the\r\nstack:\r\n\r\n```javascript\r\nHistory.revert('foo', $scope, 23);\r\n```\r\n\r\n...which will revert directly to the 23rd revision, no questions asked.\r\n\r\nIn addition, the `History.reverted` event will return to you the `pointer` that\r\nyou passed it (which is `0` by default).\r\n\r\nForgetting\r\n----------\r\n\r\nIf you want to stop watching an expression for changes, issue:\r\n\r\n```javascript\r\nHistory.forget('foo', $scope);\r\n```\r\n\r\nThe history will be purged and the watch will be removed.\r\n\r\nFanciness: Deep Watching\r\n------------------------\r\n\r\nMaybe it could use a different name, but often situations arise where you want\r\nto watch an entire array of objects for a change in any of those objects'\r\nproperties.  It would be incredibly inefficient to watch the entire array/object\r\nfor changes, and you wouldn't necessarily know what property got updated.\r\n\r\n\"Deep watch\" like so:\r\n\r\n```javascript\r\n$scope.foos = [\r\n  {id: 1, name: 'winken'},\r\n  {id: 2, name: 'blinken'},\r\n  {id: 3, name: 'nod'}\r\n];\r\nHistory.deepWatch('f.name for f in foos', $scope, \r\n  'Foo with ID {{f.id}} changed to {{f.name}}');\r\n```\r\n\r\nThis works for objects as well:\r\n\r\n```javascript\r\n$scope.foos = {\r\n  '1': {name: 'fe'},\r\n  '2': {name: 'fi'},\r\n  '3': {name: 'fo'},\r\n  '4': {name: 'fum'}\r\n};\r\nHistory.deepWatch('value.name for (key, value) in foos', $scope, \r\n  'Foo with ID {{key}} changed its name to {{value.name}}');\r\n```\r\n\r\nNow, whenever a name of any one of those things changes, history will be put on\r\nthe stack.\r\n\r\nThere are two ways to handle this.\r\n\r\n### Listen for an event\r\n\r\nThe first is to listen for the `History.archived` event:\r\n\r\n```javascript\r\nHistory.deepWatch('f.name for f in foos', $scope, \r\n  'Foo with ID {{f.id}} changed to {{f.name}}');\r\n\r\n$scope.$on('History.archived', function(evt, data) {\r\n  $scope.undo = function() {\r\n    History.undo(data.expression, data.locals);\r\n  };\r\n});\r\n\r\n$scope.foos[0].name = 'fuh';\r\n\r\n```\r\n\r\nSo you can bind to `undo()` in your view, and it will undo the change to\r\n`foos[0].name`.\r\n\r\n`data`, as passed to the event handler, will look similar to the\r\n`History.undone` event as mentioned above:\r\n\r\n- `expression`: The expression that got archived, local to `locals`\r\n- `oldValue`: The value the expression was changed from.  This is a copy!\r\n- `newValue`: The value the expression was changed to.\r\n- `description`: The optional `description` you may have passed\r\n- `locals`: A scope containing your expression's value.  For example, above we\r\nwill have the object `f` available in `locals`, with a `name` property.\r\n\r\n### Use a handler\r\n\r\nThe second way is to use a handler built into a `Watch` object:\r\n\r\n```javascript\r\nvar w = History.deepWatch('f.name for f in foos', $scope,\r\n  'Foo with ID {{f.id}} changed to {{f.name}}');\r\n\r\nw.addChangeHandler('myChangeHandler', function($expression, $locals, foo) {\r\n  $scope.undo = function() {\r\n    console.log('undoing foo with name \"' + foo.name + '\"');\r\n    History.undo($expression, $locals);\r\n  });\r\n}, {foo: 'f'});\r\n\r\n$scope.foos[0].name = 'fuh';\r\n\r\n```\r\n\r\nThere are two special injections into your change/undo/redo/etc. handlers:\r\n\r\n- `$expression` The expression that changed.  This may be simple, like `foo`,\r\nor complex like `f.name` if you have used a deep watch.\r\n- `$locals` The scope against which the change was made.  If this is simple,\r\nlike in the case of a `History.watch()`, you probably don't need it.  But if\r\nyou are doing a deep watch, then you will want to use this, because it does not\r\nrepresent the scope you originally started with!\r\n\r\n`$expression` is not available in rollback handlers (discussed later).\r\n\r\nOtherworldly Fanciness: Batching\r\n--------------------------------\r\n\r\nYou can group a bunch of changes together and undo them all at once.  Note that\r\ncurrently you must actually be watching the changed variables in some manner;\r\nyou must use `watch()` or `deepWatch()` first, then issue the batch.\r\n\r\n```javascript\r\n// setup some data\r\nscope.$apply('foo = [1,2,3]');\r\nscope.$apply('bar = \"baz\"');\r\nscope.$apply(function () {\r\n  scope.data = [\r\n    {id: 1, name: 'foo'},\r\n    {id: 2, name: 'bar'},\r\n    {id: 3, name: 'baz'}\r\n  ];\r\n  scope.otherdata = {\r\n    1: {\r\n      name: 'foo'\r\n    },\r\n    2: {\r\n      name: 'bar'\r\n    },\r\n    3: {\r\n      name: 'baz'\r\n    }\r\n  };\r\n});\r\n\r\n// watch some of these things through various means\r\nHistory.watch('foo', scope, 'foo array changed');\r\nHistory.watch('bar', scope, 'bar string changed');\r\nHistory.deepWatch('d.name for d in data', scope, 'name in data changed');\r\nHistory.deepWatch('od.name for (key, od) in otherdata', scope,\r\n  'name in otherdata changed');\r\n\r\n// change some things outright\r\nscope.$apply('pigs = \"chickens\"');\r\nscope.$apply('foo = [4,5,6]');\r\n```\r\n\r\nNext we'll initiate a batch.  You will receive a special new scope within your\r\n`Watch` object that you can then pass to `History.rollback()`, which will roll\r\nback all changes made within the batch closure.  See below.\r\n\r\nThe function you pass to `History.batch()` will accept a scope parameter, and\r\nthat is actually a child scope of the real scope.  Changes are made here and\r\npropagated to the parent's history.\r\n\r\nNote the second parameter, which is optional and defaults to `$rootScope`,\r\njust like the other functions in the API.\r\n\r\n```javascript\r\nvar w = History.batch(function (child) {\r\n  child.$apply('foo[0] = 7');\r\n  child.$apply('foo[1] = 8');\r\n  child.$apply('foo[2] = 9'); // 3 changes to \"foo\"\r\n  child.$apply('data[0].name = \"marvin\"'); // one change to the \"data\" array\r\n  child.$apply('otherdata[1].name = \"pookie\"'); // one change to the \"otherdata\" array\r\n  child.$apply('bar = \"spam\"'); // change to a string\r\n  child.$apply('pigs = \"cows\"'); // change to something *not* watched\r\n}, scope);\r\n```\r\n\r\n*You do not have to use the `child` variable unless you want to*.  It's\r\nperfectly legit, if you are in a digest loop already, to just make assignments.\r\nThe following is equivalent, again, if you are already in a digest (if you are\r\nusing this code in a controller, you are likely in a digest; if you're using\r\nit in a directive, you may or may not be depending on what you're up to):\r\n\r\n```javascript\r\nvar w = History.batch(function (child) {\r\n  scope.foo[0] = 7;\r\n  scope.foo[1] = 8;\r\n  scope.foo[2] = 9;\r\n  scope.data[0].name = \"marvin\";\r\n  scope.otherdata[1].name = \"pookie\";\r\n  scope.bar = \"spam\";\r\n  scope.pigs = \"cows\";\r\n}, scope);\r\n```\r\n\r\nLet's make sure to notify our lovely `console` that a rollback happened:\r\n\r\n```javascript\r\nw.addRollbackHandler('myRollbackHandler', function($locals) {\r\n  // $locals is the same as the \"transaction\" property of the watch object \"w\"\r\n  console.log('a rollback happened against scope ' + $locals.$id);\r\n});\r\n```\r\n\r\nNow let's issue a rollback.  Note that you can also listen for the\r\n`History.batchBegan` and `History.batchEnded` events that are broadcast from the\r\n`$rootScope`, if you want to implement more general functionality.\r\n\r\n```javascript\r\nvar transaction = w.transaction;\r\nHistory.rollback(transaction);\r\n```\r\n\r\nLet's see what we ended up with by viewing some assertions:\r\n\r\n```javascript\r\nQ.deepEqual(scope.foo, [4, 5, 6], 'foo is again [4,5,6]');\r\nQ.equal(scope.bar, 'baz', 'bar is again baz');\r\n// no change here, because we didn't watch \"pigs\"\r\nQ.equal(scope.pigs, 'cows', 'pigs is still cows (no change)');\r\nQ.equal(scope.data[0].name, 'foo', 'data[0].name is again \"foo\"');\r\nQ.equal(scope.otherdata[1].name, 'foo', 'otherdata[1].name is again foo');\r\n\r\n// see that you can undo further in some cases\r\nHistory.undo('foo', scope);\r\nQ.deepEqual(scope.foo, [1, 2, 3], 'foo is again [1,2,3]');\r\n\r\n// see you can redo again\r\nHistory.redo('foo', scope);\r\nQ.deepEqual(scope.foo, [4, 5, 6], 'foo is again [4,5,6]');\r\n\r\n// but also that you can't redo past the rollback.\r\n// I suppose this could change, but it would put a lot\r\n// of extra crap in the history.\r\nQ.ok(!History.canRedo('foo', scope), 'assert no more history');\r\n```\r\n\r\nThis batching hasn't been tested with the \"lazy\" functionality mentioned earlier\r\n(yet), but it will certainly help you support mass changes to many variables at\r\nonce, and be able to report those changes to the user.\r\n\r\nInternals\r\n---------\r\nTo debug, you can grab the stack itself by asking the service for it:\r\n\r\n```javascript\r\nconsole.log(History.history);\r\n```\r\n\r\nProperties of the `History` service include:\r\n\r\n- `history` (the complete history stack for all of the scopes and expressions)\r\n- `pointers` (which keeps a pointer to the index in the `history` we are at)\r\n- `watches` (which are the actual `$watch` functions on the Scope objects)\r\n- `lazyWatches` (which are the stored \"lazy\" watches if you are using them)\r\n- `watchObjs` (which stores all `Watch` objects created)\r\n- `descriptions` (which stores any `description` parameters passed to `watch()`)\r\n\r\nAuthor\r\n======\r\n\r\n[Christopher Hiller](http://boneskull.github.io) at\r\n[Decipher, Inc.](http://decipherinc.github.io)\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}